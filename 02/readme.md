# From Source to Binary

- In programming, everything starts with ** source code** .

- In reality, source code, which sometimes goes by the other name of the code base,
usually consists of a number of **text files** .
Within that, each of those text files **contains textual instructions** written in a programming language.

- We know that a CPU cannot execute textual instructions.

- The reality is that these instructions should first be compiled (or translated) to machine-level instructions
in order to be executed by a CPU, which eventually will result in a running program. 


- In this chapter, we go through the steps needed to get a final product out of
C source code. 

- This chapter goes into the subject in great depth, and as such
we've split it into five distinct sections:

1. **The standard C compilation pipeline** : In the first section, we are going
to cover standard C compilation, the various steps in the pipeline, and
how they contribute to producing the final product from C source code.

2. **Preprocessor** : In this section, we are going to talk about the preprocessor
component, which drives the preprocessing step, in greater depth.

3. **Compiler** : In this section, we are going to have a deeper look at compilers.
We will explain how compilers, driving the compilation step, produce
intermediate representations from source code and then translate them into
assembly language.

4. **Assemblers** : After compilers, we also talk about assemblers, which play
a significant role in translating the assembly instructions, received from
compiler, into machine-level instructions. The assembler component
drives the assembly step.

5. **Linker** : In the last section, we will discuss the linker component, driving
the linking step, in greater depth.

- The linker is a build component that finally creates the actual products of a C project.
There are build errors that are specific to this component, and sufficient knowledge of the linker
will help us to prevent and resolve them. We also discuss the various final
products of a C project, and we will give some hints about disassembling
an object file and reading its content.

- More than that, we discuss briefly what C++ name mangling is and how it prevents certain defects in the
linking step when building C++ code.


- Our discussions in this chapter are mostly themed around Unix-like systems,
but we discuss some differences in other operating systems, such as Microsoft Windows.

- In the first section, we need to explain the **C compilation pipeline.** 
It is vital(必不可少的) to know how the pipeline produces the executable and library files from the source
code.

- While there are multiple concepts and steps involved, understanding them
thoroughly is vital for us if we are to be prepared for the content in both this
and future chapters. Note that the various products of a C project are discussed
thoroughly in the next chapter, Object Files.

## Compilation pipeline

- Compiling some C files usually takes a few seconds, but during this brief period
of time, the source code enters a pipeline that has four distinct components, with
each of them doing a certain task. These components are as follows:
    - Preprocessor
    - Compiler
    - Assembler
    - Linker


- Each component in this pipeline accepts a certain input from the previous
component and produces a certain output for the next component in the pipeline.
This process continues through the pipeline until a product is generated by the
last component.

- Source code can be turned into a product if, and only if, it passes through all the
required components with success. This means that even a small failure in one
of the components can lead to a **compilation**  or **linkage**  failure, resulting in you
receiving relevant error messages.

- For certain intermediate products(中间产品) such as **relocatable object files** ,
it is enough that a single source file goes through the first three components with success. 

- The last component, the linker, is usually used to create bigger products, such as an
executable object file, by merging some of the already prepared relocatable object
files. So, building a collection of C source files can create one or sometimes
multiple object files, including relocatable, executable, and shared object files.

- There are currently a variety of C compilers available. While some of them are
free and open source, others are proprietary and commercial. Likewise, some
compilers will only work on a specific platform while others are cross-platform,
although, the important note is that almost every platform has at least one
compatible C compiler.

- Note:
- For a complete list of available C compilers, please have a look
at the following Wikipedia page: [list of available C compilers](https://en.wikipedia.org/wiki/List_of_compilers#C_compilers) 

- Before talking about the default platform and the C compiler that we use
throughout this chapter, let's talk a bit more about the term **platform**, and what we mean by it.

- A platform is a combination of an operating system running on specific hardware
(or architecture), and its CPU's instruction set is the most important part of it.

- The operating system is the software component of a platform, and the architecture
defines the hardware part. As an example, we can have Ubuntu running on an
ARM-powered board, or we could have Microsoft Windows running on an AMD 64-bit CPU.

- Cross-platform software can be run on different platforms. However, it is vital (必不可少的) to
know that **cross-platform is different from being portable**.

- **Cross-platform**  software usually has different **binaries**  (final object files) and **installers**  for each platform,
while **portable software**  uses the **same produced binaries and installers on all platforms**.

- Some C compilers, for example, `gcc` and`clang`, are **cross-platform**  – they
can generate code for different platforms – and `Java` bytecode is portable.

- Regarding C and C++, if we say that **C/C++ code is portable** , we mean that
we can compile it for different platforms without any change or with little
modification to the source code.

-  **This doesn't mean that the final object files are portable** , however.


- If you have looked at the Wikipedia article we noted before, you can see that
there are numerous C compilers. Fortunately for us, all of them follow the **same** 
standard compilation pipeline that we are going to introduce in this chapter.

- Among these many compilers, we need to choose one of them to work with
during this chapter. Throughout this chapter, we will be using `gcc 7.3.0` as our
default compiler.

- We are choosing gcc because it is available on most operating
systems, in addition to the fact that there are many online resources to be found
for it.

- We also need to choose our default platform. In this chapter, we have chosen
Ubuntu 18.04 as our default operating system running on an AMD 64-bit CPU
as our default architecture.

- From time to time this chapter might refer to a different
compiler, a different operating system, or a different
architecture to compare various platforms and compilers.
If we do so, the specification of the new platform or the new
compiler will be given beforehand.

- In the following sections, we are going to describe the steps in the compilation
pipeline.
- First, we are going to build a simple example to see how the sources
inside a C project are compiled and linked. 

- Throughout this example, we will become familiar with new terms and concepts regarding the compilation process.

- Only after that do we address each component individually in a separate section.

There, we go deep in to each component to explain more internal concepts
and processes.

## Building a C project

- In this section, we are going to demonstrate how a C project is built. The project
that we are going to work on consists of more than one source file, which is
a common characteristic of almost all C projects.
- However, before we move to
the example and start building it, we need to ensure that we understand the **structure of a typical C project.** 


## Header files versus source files
- Every C project has source code, or code base, together with other documents
related to the project description and existing standards.

- In a C code base, we usually have two kinds of files that contain C code:

- **Header files** , which usually have a `.h` extension in their names.

- **Source files** , which have a `.c` extension.
- Note:
    - For convenience, in this chapter, we may use the terms header
    - instead of header file and source instead of source file.

- A header file usually contains `enumerations`, `macros`, and `typedefs`, as well
as the `declarations of functions`, `global variables`, and `structures`.

- In C, some programming elements such as functions, variables, and structures can have
their declaration separated from their definition placed in different files.

- C++ follows the same pattern, but in other programming languages, such as `Java`,
the elements are defined where they are declared.
- While this is a great feature of both C and C++, as it gives them the power to decouple(解 耦) the declarations from
definitions, it also makes the source code more complex.

- As a rule of thumb, the declarations are stored in header files, and the
corresponding definitions go to source files.

- This is even more critical with regard to function declarations and function definitions.

- It is strongly recommended that you only keep function declarations in header
files and move function definitions to the corresponding source files. 
- While this is not necessary, it is an important design practice to keep those function definitions out of the header files.

- While the structures could also have separate declarations and definitions, there
are special cases in which we move declarations and definitions to different files.

We will see an example of this in Chapter 8, Inheritance and Polymorphism, where
we will be discussing the inheritance relationship between classes





